import argparse

GREEN = '\033[0;36m'  # 32
RED = '\033[0;31m'
YELLOW = '\033[0;33m'  # 32
BLUE = '\033[0;34m'  #
VIOLET = '\033[0;35m'  #
BOLD = '\033[1m'
NC = '\033[0m'

_COLOR_TO_CODE = {
    'g': GREEN,
    'r': RED,
    'y': YELLOW,
    'b': BLUE,
    'v': VIOLET,
    'bold': BOLD
}


class ArgumentParser(argparse.ArgumentParser):

    def error(self, message):
        # self.print_help(sys.stderr)
        # self.print_usage(sys.stderr)
        print(self.format_usage().splitlines()[0])
        self.exit(2, color_msg(f'\nerror: {message}\n', 'r'))


# Ref.: https://stackoverflow.com/a/32891625/14664104
class MyFormatter(argparse.RawDescriptionHelpFormatter):
    """
    Corrected _max_action_length for the indenting of subactions
    """

    def add_argument(self, action):
        if action.help is not argparse.SUPPRESS:

            # find all invocations
            get_invocation = self._format_action_invocation
            invocations = [get_invocation(action)]
            current_indent = self._current_indent
            for subaction in self._iter_indented_subactions(action):
                # compensate for the indent that will be added
                indent_chg = self._current_indent - current_indent
                added_indent = 'x' * indent_chg
                invocations.append(added_indent + get_invocation(subaction))
            # print('inv', invocations)

            # update the maximum item length
            invocation_length = max([len(s) for s in invocations])
            action_length = invocation_length + self._current_indent
            self._action_max_length = max(self._action_max_length,
                                          action_length)

            # add the item to the list
            self._add_item(self._format_action, [action])

    # Ref.: https://stackoverflow.com/a/23941599/14664104
    def _format_action_invocation(self, action):
        if not action.option_strings:
            metavar, = self._metavar_formatter(action, action.dest)(1)
            return metavar
        else:
            parts = []
            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            # change to
            #    -s, --long ARGS
            else:
                default = action.dest.upper()
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    # parts.append('%s %s' % (option_string, args_string))
                    parts.append('%s' % option_string)
                parts[-1] += ' %s'%args_string
            return ', '.join(parts)


def color_msg(msg, color='y', bold=False):
    color = color.lower()
    colors = list(_COLOR_TO_CODE.keys())
    assert color in colors, f'Wrong color: {color}. Only these colors are ' \
                            f'supported: {colors}'
    if bold:
        msg = f'{BOLD}{msg}{NC}'
    return f'{_COLOR_TO_CODE[color]}{msg}{NC}'


def get_default_message(default_value):
    return f' ({GREEN}default: {default_value}{NC})'
